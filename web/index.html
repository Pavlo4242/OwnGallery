<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Local Media Gallery</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 0;
            background-color: #f0f0f0;
            color: #333;
        }

        .controls {
            padding: 15px;
            background-color: #fff;
            border-bottom: 1px solid #ddd;
            text-align: center;
        }

        .controls label {
            margin-right: 10px;
        }

        .controls input[type="range"] {
            width: 200px;
            vertical-align: middle;
        }

        .controls input[type="text"] {
            width: 300px;
            padding: 8px;
            margin-right: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .controls button {
            padding: 8px 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .controls button:hover {
            background-color: #0056b3;
        }

        .grid {
            margin: 10px;
            min-height: 100vh;
            overflow: visible;
        }

        .grid-item {
            width: 250px;
            margin-bottom: 10px;
            box-sizing: border-box;
            overflow: hidden;
            cursor: pointer;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .grid-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .grid-item img,
        .grid-item video {
            display: block;
            width: 100%;
            height: auto;
            border-radius: 8px;
        }

        .fullscreen-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }

        .fullscreen-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .fullscreen-content {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
        }

        .fullscreen-content img,
        .fullscreen-content video {
            max-width: calc(100vw - 20px);
            max-height: calc(100vh - 20px);
            object-fit: contain;
            border-radius: 4px;
        }

        .nav-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background-color: rgba(255, 255, 255, 0.9);
            border: none;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            font-weight: bold;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.2s ease;
            z-index: 1002;
        }

        .nav-btn:hover {
            background-color: white;
            transform: translateY(-50%) scale(1.1);
        }

        .nav-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .prev-btn {
            left: 20px;
        }

        .next-btn {
            right: 20px;
        }

        .close-btn {
            position: absolute;
            top: 20px;
            right: 30px;
            color: #fff;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1002;
            background-color: rgba(0, 0, 0, 0.5);
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s ease;
        }

        .close-btn:hover {
            background-color: rgba(0, 0, 0, 0.8);
        }

         .media-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 15px;
            font-size: 14px;
            z-index: 1002;
            pointer-events: none;
        }

        /* ===== UPDATED: PLAYBACK CONTROLS - NOW ON RIGHT SIDE ===== */
        .playback-controls {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 15px;
            z-index: 1002;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: stretch;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .playback-controls.auto-hide {
            opacity: 0;
            pointer-events: none;
        }

        .playback-controls:hover {
            opacity: 1 !important;
            pointer-events: all !important;
        }

        .playback-controls button {
            background-color: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            color: white;
            padding: 10px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .playback-controls button:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }

        .playback-controls button.active {
            background-color: #4CAF50;
            border-color: #4CAF50;
        }

        .playback-controls .timing-control {
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: center;
        }

        .playback-controls input[type="number"] {
            width: 80px;
            padding: 5px;
            border-radius: 5px;
            border: none;
            text-align: center;
        }

        .playback-controls label {
            color: white;
            font-size: 11px;
            text-align: center;
        }
        /* ===== END PLAYBACK CONTROLS UPDATE ===== */

        .loading, .error {
            text-align: center;
            padding: 40px;
            font-size: 18px;
        }

        .error {
            color: #d32f2f;
        }
    </style>
</head>
<body>
      <div class="controls">
        <button onclick="initializeGallery()">Load Gallery</button>
        <label for="thumbnailWidth" style="margin-left: 20px;">Thumbnail Width:</label>
        <input type="range" id="thumbnailWidth" min="100" max="400" value="250">
        <label for="folderFilter" style="margin-left: 20px;">Folder:</label>
        <select id="folderFilter" onchange="filterGalleryByFolder()" style="padding: 8px; border-radius: 4px;">
            <option value="all">All Files</option>
        </select>
        <label style="margin-left: 20px;">
            <input type="checkbox" id="shuffleToggle" checked> Shuffle
        </label>
        <button onclick="forceReshuffle()" style="margin-left: 10px;">Re-shuffle</button>
        <button onclick="resetViewed()" style="margin-left: 10px;">Reset Viewed</button>
    </div>
	
	   </div>

    <div class="grid"></div>
    
    <div id="endOfGallery" style="display: none; text-align: center; padding: 40px; background: white; margin: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
        <h3>End of Gallery</h3>
        <p>You've reached the end of this folder.</p>
        <button onclick="scrollToTop()" style="padding: 12px 24px; margin: 10px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px;">Back to Top</button>
        <div style="margin-top: 20px;">
            <label for="bottomFolderFilter" style="margin-right: 10px;">Switch Folder:</label>
            <select id="bottomFolderFilter" onchange="switchFolderFromBottom()" style="padding: 8px; border-radius: 4px; min-width: 200px;">
                <option value="">Select a folder...</option>
            </select>
        </div>
    </div>

    <div id="fullscreenOverlay" class="fullscreen-overlay">
        <span class="close-btn">&times;</span>
        <button class="nav-btn prev-btn" id="prevBtn">‹</button>
        <button class="nav-btn next-btn" id="nextBtn">›</button>
        <div class="fullscreen-content"></div>
        <div class="media-info" id="mediaInfo"></div>
        <!-- ===== PLAYBACK CONTROLS MARKUP ===== -->
        <div class="playback-controls" id="playbackControls">
            <button id="playPauseBtn">▶ Play</button>
            <div class="timing-control">
                <label>Advance Time</label>
                <input type="number" id="advanceTime" min="500" max="30000" step="100" value="3000">
                <label>milliseconds</label>
            </div>
            <button onclick="scrollToTop()" style="margin-top: 10px;">↑ Back to Top</button>
        </div>
        <!-- ===== END PLAYBACK CONTROLS MARKUP ===== -->
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/masonry/4.2.2/masonry.pkgd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/5.0.0/imagesloaded.pkgd.min.js"></script>

    <script>
        let allMediaFiles = [];
        let MEDIA_DATA = {};
		let FOLDER_MAP = {}; // Holds all files, grouped by folder
                let masonry;
        let loadedMediaCount = 0;
        const filesPerLoad = 20;
        const supportedExtensions = ['.jpg', '.jpeg', '.png', '.webp', '.gif', '.mp4', '.webm', '.ogg'];
        let currentMediaIndex = -1;
        let autoAdvanceInterval = null;
        let isPlaying = false;
        let viewedFiles = new Set(); // Track which files have been viewed
        let viewHistory = []; // Track order of views for resetting
        
        // ===== MOUSE GESTURE VARIABLES =====
        let rightButtonDown = false;
        let gestureUsed = false;
        // ===== END MOUSE GESTURE VARIABLES =====
        
         // Auto-hide controls timer
        let controlsHideTimer = null;
        let speedIndicatorTimer = null;

        function showSpeedIndicator(delayMs) {
            let indicator = document.getElementById('speedIndicator');
            
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'speedIndicator';
                indicator.style.cssText = `
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background-color: rgba(0, 0, 0, 0.8);
                    color: white;
                    padding: 20px 40px;
                    border-radius: 10px;
                    font-size: 24px;
                    z-index: 1003;
                    pointer-events: none;
                `;
                document.getElementById('fullscreenOverlay').appendChild(indicator);
            }
            
            const seconds = (delayMs / 1000).toFixed(1);
            indicator.textContent = `Speed: ${seconds}s`;
            indicator.style.display = 'block';
            
            clearTimeout(speedIndicatorTimer);
            speedIndicatorTimer = setTimeout(() => {
                indicator.style.display = 'none';
            }, 1000);
        }

// Auto-detect web server base path and load files
async function initializeGallery() {
    const grid = document.querySelector('.grid');
    
    grid.innerHTML = '<div class="loading">Loading media files...</div>';
    
    try {
        // Get the directory where this HTML file is located
        const htmlPath = window.location.pathname;
        const htmlDir = htmlPath.substring(0, htmlPath.lastIndexOf('/') + 1);
        
        const jsonPath = htmlDir + 'filelist.json';
        console.log('Loading from:', jsonPath);
        
        const response = await fetch(jsonPath);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: Could not load filelist.json from ${jsonPath}`);
        }
        
        const text = await response.text();
        const fileList = JSON.parse(text);

        if (fileList.length === 0) {
            grid.innerHTML = `<div class="error">No supported media files found!</div>`;
            return;
        }

        console.log('HTML directory:', htmlDir);
        console.log('Total files:', fileList.length);

        // --- Build folder structure using relative paths ---
        FOLDER_MAP = { 'all': [] };
        MEDIA_DATA = {};
        
        fileList.forEach((relativePath, index) => {
            // relativePath is like "ANIMATED/pf867_anim.mp4" or "FEMALE/pf29.jpg"
            // Convert to full web URL by prepending the HTML directory
            const webUrl = htmlDir + relativePath;
            
            // Store mapping: relative path -> web URL
            MEDIA_DATA[relativePath] = webUrl;
            
            // Debug first 3 entries
            if (index < 3) {
                console.log(`Entry ${index}: relative="${relativePath}", url="${webUrl}"`);
            }
            
            // Add to 'all' list
            FOLDER_MAP['all'].push(relativePath);

            // Parse folders from relative path
            const parts = relativePath.split('/');
            let folderName = '(root)';
            if (parts.length > 1) {
                folderName = parts.slice(0, -1).join('/');
            }
            if (!FOLDER_MAP[folderName]) {
                FOLDER_MAP[folderName] = [];
            }
            FOLDER_MAP[folderName].push(relativePath);
        });
        
        console.log('Parsed folders:', Object.keys(FOLDER_MAP));
        console.log('Sample MEDIA_DATA:', Object.entries(MEDIA_DATA).slice(0, 2));
        
        populateFolderFilter();
        filterGalleryByFolder();

    } catch (error) {
        console.error('Error loading directory:', error);
        grid.innerHTML = `<div class="error">
            <strong>Error loading media:</strong> ${error.message}<br><br>
            <strong>Troubleshooting:</strong><br>
            1. Check browser console (F12) for detailed errors<br>
            2. Run python gen-filelist.py in the same directory as this HTML file<br>
            3. Make sure you're running a web server (not file:///)
        </div>`;
    }
}


function populateFolderFilter() {
    const select = document.getElementById('folderFilter');
    const bottomSelect = document.getElementById('bottomFolderFilter');
    
    select.innerHTML = '<option value="all">All Files</option>';
    bottomSelect.innerHTML = '<option value="">Select a folder...</option>';
    
    const folderNames = Object.keys(FOLDER_MAP).sort();
    
    folderNames.forEach(folderName => {
        if (folderName === 'all') return;
        
        const option = document.createElement('option');
        option.value = folderName;
        const depth = (folderName.match(/\//g) || []).length;
        option.innerHTML = `${'&nbsp;'.repeat(depth * 4)}${folderName} (${FOLDER_MAP[folderName].length})`;
        select.appendChild(option);
        
        // Clone for bottom select
        const bottomOption = option.cloneNode(true);
        bottomSelect.appendChild(bottomOption);
    });
    
    // Add "All Files" to bottom select
    const allOption = document.createElement('option');
    allOption.value = 'all';
    allOption.textContent = 'All Files';
    bottomSelect.insertBefore(allOption, bottomSelect.firstChild.nextSibling);
}

function filterGalleryByFolder() {
    const select = document.getElementById('folderFilter');
    const folderName = select.value;
    const grid = document.querySelector('.grid');
    const shuffleEnabled = document.getElementById('shuffleToggle').checked;
    
    grid.innerHTML = '';
    document.getElementById('endOfGallery').style.display = 'none';
    
    if (masonry) {
        masonry.destroy();
        masonry = null;
    }
    
    // Initialize intersection observer for memory management
    initIntersectionObserver();
    
    let filesToShow = FOLDER_MAP[folderName] || [];
    
    let displayList = [...filesToShow];
    if (shuffleEnabled) {
        shuffleArray(displayList);
    }
    
    allMediaFiles = displayList;
    
    loadedMediaCount = 0;
    loadMoreMedia();
}

function shuffleArray(array) {
    // Separate viewed and unviewed files
    const unviewed = array.filter(file => !viewedFiles.has(file));
    const viewed = array.filter(file => viewedFiles.has(file));
    
    // Shuffle both groups
    for (let i = unviewed.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [unviewed[i], unviewed[j]] = [unviewed[j], unviewed[i]];
    }
    
    for (let i = viewed.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [viewed[i], viewed[j]] = [viewed[j], viewed[i]];
    }
    
    // Put unviewed files first, then viewed files
    array.length = 0;
    array.push(...unviewed, ...viewed);
}
function forceReshuffle() {
    filterGalleryByFolder();
}

function resetViewed() {
    viewedFiles.clear();
    viewHistory = [];
    console.log('Viewing history cleared');
    filterGalleryByFolder();
}

function scrollToTop() {
    // Close fullscreen if open
    const overlay = document.getElementById('fullscreenOverlay');
    if (overlay.classList.contains('visible')) {
        closeFullscreen();
    }
    // Scroll to top
    window.scrollTo({ top: 0, behavior: 'smooth' });
}

function switchFolderFromBottom() {
    const bottomSelect = document.getElementById('bottomFolderFilter');
    const topSelect = document.getElementById('folderFilter');
    
    if (bottomSelect.value) {
        topSelect.value = bottomSelect.value;
        scrollToTop();
        filterGalleryByFolder();
    }
}

        function createMediaElement(fileName) {
            const lowerFileName = fileName.toLowerCase();
            let mediaElement;

            if (supportedExtensions.some(ext => ['.mp4', '.webm', '.ogg'].includes(ext) && lowerFileName.endsWith(ext))) {
                mediaElement = document.createElement('video');
                mediaElement.autoplay = false;
                mediaElement.muted = true;
                mediaElement.loop = true;
                mediaElement.preload = 'metadata';
                mediaElement.playsInline = true;
            } else {
                mediaElement = document.createElement('img');
                mediaElement.loading = 'lazy';
            }

            mediaElement.src = MEDIA_DATA[fileName];
            return mediaElement;
        }

        function initializeMasonry() {
            const grid = document.querySelector('.grid');
            if (masonry) {
                masonry.destroy();
            }
            masonry = new Masonry(grid, {
                itemSelector: '.grid-item',
                columnWidth: parseInt(document.getElementById('thumbnailWidth').value),
                gutter: 10,
                fitWidth: true
            });
        }

        // Intersection Observer for lazy loading and memory management
        let intersectionObserver = null;

        function initIntersectionObserver() {
            if (intersectionObserver) {
                intersectionObserver.disconnect();
            }

            intersectionObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    const mediaElement = entry.target.querySelector('img, video');
                    if (!mediaElement) return;

                    if (entry.isIntersecting) {
                        // Load media when it comes into view
                        if (!mediaElement.src && mediaElement.dataset.src) {
                            mediaElement.src = mediaElement.dataset.src;
                        }
                        // Resume video if it was paused
                        if (mediaElement.tagName === 'VIDEO') {
                            mediaElement.load();
                        }
                    } else {
                        // Unload media when it's far from view to save memory
                        if (entry.boundingClientRect.top < -1000 || entry.boundingClientRect.top > window.innerHeight + 1000) {
                            if (mediaElement.tagName === 'VIDEO') {
                                mediaElement.pause();
                                mediaElement.src = '';
                                mediaElement.load();
                            } else if (mediaElement.tagName === 'IMG') {
                                // Store src for later reload
                                if (mediaElement.src && !mediaElement.dataset.src) {
                                    mediaElement.dataset.src = mediaElement.src;
                                }
                                mediaElement.src = '';
                            }
                        }
                    }
                });
            }, {
                rootMargin: '500px', // Start loading 500px before entering viewport
                threshold: 0
            });
        }

        function appendMediaToGrid(files) {
            if (files.length === 0) return;
            
            const grid = document.querySelector('.grid');
            const thumbnailWidth = document.getElementById('thumbnailWidth').value;

            const elements = files.map((fileName) => {
                const gridItem = document.createElement('div');
                gridItem.classList.add('grid-item');
                gridItem.dataset.fileName = fileName;
                gridItem.style.width = `${thumbnailWidth}px`;

                const mediaElement = createMediaElement(fileName);
                gridItem.appendChild(mediaElement);

                gridItem.addEventListener('click', () => {
                    openFullscreen(fileName);
                });

                // Observe this element for memory management
                if (intersectionObserver) {
                    intersectionObserver.observe(gridItem);
                }

                return gridItem;
            });

            grid.append(...elements);

            if (masonry) {
                masonry.appended(elements);
                setTimeout(() => {
                    imagesLoaded(elements, function() {
                        masonry.layout();
                    });
                }, 10);
            } else {
                imagesLoaded(elements, function() {
                    initializeMasonry();
                    setTimeout(() => {
                        if (masonry) masonry.layout();
                    }, 50);
                });
            }
        }

         function loadMoreMedia() {
            const nextBatch = allMediaFiles.slice(loadedMediaCount, loadedMediaCount + filesPerLoad);
            if (nextBatch.length > 0) {
                appendMediaToGrid(nextBatch);
                loadedMediaCount += nextBatch.length;
                
                // Hide end message if loading more
                document.getElementById('endOfGallery').style.display = 'none';
            } else if (loadedMediaCount >= allMediaFiles.length && allMediaFiles.length > 0) {
                // Show end of gallery message
                document.getElementById('endOfGallery').style.display = 'block';
            }
        }

        function openFullscreen(fileName) {
    const overlay = document.getElementById('fullscreenOverlay');
    const content = document.querySelector('.fullscreen-content');
    
    currentMediaIndex = allMediaFiles.indexOf(fileName);
    if (currentMediaIndex === -1) return;
    
    // Mark as viewed
    viewedFiles.add(fileName);
    viewHistory.push(fileName);
    
    const isVideo = fileName.toLowerCase().match(/\.(mp4|webm|ogg)$/);

            content.innerHTML = '';

            let mediaElement;
            if (isVideo) {
                mediaElement = document.createElement('video');
                mediaElement.controls = true;
                mediaElement.autoplay = true;
                mediaElement.loop = true;
            } else {
                mediaElement = document.createElement('img');
            }

            mediaElement.src = MEDIA_DATA[fileName];
            content.appendChild(mediaElement);

            updateNavigationState();
            overlay.classList.add('visible');
            resetControlsTimer();
        }
        
        function updateNavigationState() {
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            const info = document.getElementById('mediaInfo');
            
            prevBtn.disabled = currentMediaIndex <= 0;
            nextBtn.disabled = currentMediaIndex >= allMediaFiles.length - 1;

            const fileName = allMediaFiles[currentMediaIndex];
            info.textContent = `${currentMediaIndex + 1} / ${allMediaFiles.length}`;
        }
		
		
        
function navigateFullscreen(direction) {
    const newIndex = currentMediaIndex + direction;
    if (newIndex >= 0 && newIndex < allMediaFiles.length) {
        currentMediaIndex = newIndex;
        const fileName = allMediaFiles[currentMediaIndex];
        
        // Mark as viewed when navigating
        viewedFiles.add(fileName);
        viewHistory.push(fileName);
        
        const content = document.querySelector('.fullscreen-content');
        const isVideo = fileName.toLowerCase().match(/\.(mp4|webm|ogg)$/);

        content.innerHTML = '';

        let mediaElement;
        if (isVideo) {
            mediaElement = document.createElement('video');
            mediaElement.controls = true;
            mediaElement.autoplay = true;
            mediaElement.loop = true;
        } else {
            mediaElement = document.createElement('img');
        }

        mediaElement.src = MEDIA_DATA[fileName];
        content.appendChild(mediaElement);

        updateNavigationState();
        resetControlsTimer();
    } else if (newIndex >= allMediaFiles.length) {
        // Reached end, stop auto-play
        stopAutoAdvance();
    } else if (newIndex < 0) {
        // Already at beginning, do nothing
        return;
    }
}

        function closeFullscreen() {
            const overlay = document.getElementById('fullscreenOverlay');
            overlay.classList.remove('visible');
            stopAutoAdvance();
            currentMediaIndex = -1;
            clearTimeout(controlsHideTimer);
        }
        
        // ===== AUTO-HIDE CONTROLS TIMER =====
        function resetControlsTimer() {
            const controls = document.getElementById('playbackControls');
            controls.classList.remove('auto-hide');
            
            clearTimeout(controlsHideTimer);
            controlsHideTimer = setTimeout(() => {
                if (isPlaying) {
                    controls.classList.add('auto-hide');
                }
            }, 3000);
        }
        // ===== END AUTO-HIDE CONTROLS TIMER =====
        
        // Auto-advance functionality
        function startAutoAdvance() {
            stopAutoAdvance();
            
            const delay = parseInt(document.getElementById('advanceTime').value) || 3000;
            autoAdvanceInterval = setInterval(() => {
                if (currentMediaIndex < allMediaFiles.length - 1) {
                    navigateFullscreen(1);
                } else {
                    stopAutoAdvance();
                }
            }, delay);
            
            isPlaying = true;
            document.getElementById('playPauseBtn').textContent = '⏸ Pause';
            document.getElementById('playPauseBtn').classList.add('active');
        }
        
        function stopAutoAdvance() {
            if (autoAdvanceInterval) {
                clearInterval(autoAdvanceInterval);
                autoAdvanceInterval = null;
            }
            isPlaying = false;
            document.getElementById('playPauseBtn').textContent = '▶ Play';
            document.getElementById('playPauseBtn').classList.remove('active');
            document.getElementById('playbackControls').classList.remove('auto-hide');
        }
        
        function togglePlayPause() {
            if (isPlaying) {
                stopAutoAdvance();
            } else {
                startAutoAdvance();
            }
        }

        // Event Listeners
        document.getElementById('thumbnailWidth').addEventListener('input', (e) => {
            const newWidth = parseInt(e.target.value);
            document.querySelectorAll('.grid-item').forEach(item => {
                item.style.width = `${newWidth}px`;
            });
            if (masonry) {
                masonry.options.columnWidth = newWidth;
                masonry.layout();
            }
        });

        document.querySelector('.close-btn').addEventListener('click', closeFullscreen);
        
        document.getElementById('prevBtn').addEventListener('click', () => navigateFullscreen(-1));
        document.getElementById('nextBtn').addEventListener('click', () => navigateFullscreen(1));
        
        document.getElementById('playPauseBtn').addEventListener('click', togglePlayPause);
        
        // Update timing while playing
        document.getElementById('advanceTime').addEventListener('change', () => {
            if (isPlaying) {
                startAutoAdvance(); // Restart with new timing
            }
        });

        // Keyboard Navigation
        document.addEventListener('keydown', (e) => {
            const overlay = document.getElementById('fullscreenOverlay');
            if (!overlay.classList.contains('visible')) return;
            
            if (e.key === 'ArrowRight' || e.key === 'PageDown' || e.key === 'd') {
                e.preventDefault();
                navigateFullscreen(1);
            } else if (e.key === 'ArrowLeft' || e.key === 'PageUp' || e.key === 'a') {
                e.preventDefault();
                navigateFullscreen(-1);
            } else if (e.key === 'Escape') {
                e.preventDefault();
                closeFullscreen();
            } else if (e.key === ' ') {
                e.preventDefault();
                togglePlayPause();
            } else if (e.key === 'Home') {
                e.preventDefault();
                currentMediaIndex = 0;
                navigateFullscreen(0);
            } else if (e.key === 'End') {
                e.preventDefault();
                currentMediaIndex = allMediaFiles.length - 1;
                navigateFullscreen(0);
            }
        });
        
           // ===== IMPROVED MOUSE GESTURES WITH PAUSE-ON-HOLD =====
        let mouseDownTime = 0;
        let pausedByHold = false;
        
        document.getElementById('fullscreenOverlay').addEventListener('mousedown', (e) => {
            const overlay = document.getElementById('fullscreenOverlay');
            if (!overlay.classList.contains('visible')) return;
            
            // Ignore clicks on close button and controls
            if (e.target.closest('.close-btn') || 
                e.target.closest('.playback-controls') ||
                e.target.closest('.nav-btn')) {
                return;
            }
            
            if (e.button === 0) { // Left click
                e.preventDefault();
                mouseDownTime = Date.now();
                
                // If playing, pause temporarily
                if (isPlaying) {
                    stopAutoAdvance();
                    pausedByHold = true;
                }
                
                gestureUsed = true;
            } else if (e.button === 2) { // Right click
                e.preventDefault();
                rightButtonDown = true;
                gestureUsed = true;
            }
        });

        document.getElementById('fullscreenOverlay').addEventListener('mouseup', (e) => {
            const overlay = document.getElementById('fullscreenOverlay');
            if (!overlay.classList.contains('visible')) return;
            
            if (e.button === 0) { // Left mouse button released
                const holdDuration = Date.now() - mouseDownTime;
                
                // If was paused by hold, resume
                if (pausedByHold) {
                    startAutoAdvance();
                    pausedByHold = false;
                } 
                // If quick click (< 200ms) and not playing, advance one image
                else if (holdDuration < 200 && currentMediaIndex < allMediaFiles.length - 1) {
                    navigateFullscreen(1);
                }
            } else if (e.button === 2) {
                rightButtonDown = false;
            }
        });

        // Mouse wheel controls playback speed
        document.getElementById('fullscreenOverlay').addEventListener('wheel', (e) => {
            const overlay = document.getElementById('fullscreenOverlay');
            if (!overlay.classList.contains('visible')) return;
            
            // Ignore wheel on controls
            if (e.target.closest('.playback-controls') || e.target.closest('.nav-btn')) {
                return;
            }
            
            e.preventDefault();
            
            const advanceTimeInput = document.getElementById('advanceTime');
            let currentDelay = parseInt(advanceTimeInput.value);
            
            // Scroll up = faster (decrease delay), scroll down = slower (increase delay)
            if (e.deltaY < 0) {
                // Faster - decrease by 500ms, minimum 500ms
                currentDelay = Math.max(500, currentDelay - 500);
            } else {
                // Slower - increase by 500ms, maximum 30000ms
                currentDelay = Math.min(30000, currentDelay + 500);
            }
            
            advanceTimeInput.value = currentDelay;
            
            // If playing, restart with new timing
            if (isPlaying) {
                startAutoAdvance();
            }
            
            // Show a temporary speed indicator
            showSpeedIndicator(currentDelay);
        }, { passive: false });

        // Prevent context menu in fullscreen view
        document.getElementById('fullscreenOverlay').addEventListener('contextmenu', (e) => {
            const overlay = document.getElementById('fullscreenOverlay');
            if (overlay.classList.contains('visible')) {
                e.preventDefault();
                // If right button was used as gesture, go back
                if (gestureUsed && currentMediaIndex > 0) {
                    navigateFullscreen(-1);
                }
                gestureUsed = false;
            }
        });
        // ===== END IMPROVED MOUSE GESTURES =====

        // Mouse movement shows controls
        document.getElementById('fullscreenOverlay').addEventListener('mousemove', () => {
            resetControlsTimer();
        });

        window.addEventListener('scroll', () => {
            const grid = document.querySelector('.grid');
            if ((window.innerHeight + window.scrollY) >= (document.body.offsetHeight - 500) &&
                loadedMediaCount < allMediaFiles.length) {
                loadMoreMedia();
            }
        });

        // Auto-load on page load
        window.addEventListener('DOMContentLoaded', () => {
            initializeGallery();
        });

        // Generate file list by calling PHP script
        async function generateFileList() {
            const mediaPath = document.getElementById('mediaPath').value;
            const grid = document.querySelector('.grid');
            
            grid.innerHTML = '<div class="loading">Generating file list...</div>';
            
            try {
                const response = await fetch(`${mediaPath}create-filelist.php`);
                const result = await response.json();
                
                if (result.success) {
                    grid.innerHTML = `<div style="color: green; padding: 40px;">
                        Successfully generated filelist.json with ${result.count} files!<br>
                        <button onclick="loadFromDirectory()" style="margin-top: 10px;">Load Gallery Now</button>
                    </div>`;
                } else {
                    throw new Error('Failed to generate file list');
                }
            } catch (error) {
                grid.innerHTML = `<div class="error">Error: ${error.message}<br>
                    Make sure create-filelist.php exists and you're running a web server.</div>`;
            }
        }
    </script>
</body>
</html>